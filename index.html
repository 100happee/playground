<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>3D Platformer Playground</title>
  <style>
    body { margin: 0; overflow: hidden; background: #101418; color: white; font-family: sans-serif; }
    #info { position: absolute; top: 10px; left: 10px; z-index: 1; background: rgba(0,0,0,0.4); padding: 8px 12px; border-radius: 8px; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="info">
  <b>3D Platformer Test</b><br>
  Move: WASD — Jump: Space — Drag: Rotate camera
</div>

<!-- THREE.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let player, controls = {}, velocity = new THREE.Vector3();
let objects = [], keys = {};
let canJump = false;

// Scene setup
scene = new THREE.Scene();
scene.background = new THREE.Color(0x11161f);

// Camera setup
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 3, 8);

// Renderer setup
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

// Ground (grid)
const groundSize = 200;
const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x222831 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Add grid helper
const grid = new THREE.GridHelper(groundSize, groundSize / 2, 0x555555, 0x333333);
scene.add(grid);

// Player cube
const playerGeo = new THREE.BoxGeometry(1, 1, 1);
const playerMat = new THREE.MeshStandardMaterial({ color: 0x00aaff });
player = new THREE.Mesh(playerGeo, playerMat);
player.position.y = 2;
scene.add(player);

// Platforms / obstacles
function addPlatform(x, y, z, w=2, h=0.5, d=2, color=0xff8844){
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color });
  const platform = new THREE.Mesh(geo, mat);
  platform.position.set(x, y, z);
  scene.add(platform);
  objects.push(platform);
}

// Create some platforms
addPlatform(0, 0.25, 0, 30, 0.5, 30, 0x334455); // big ground base
addPlatform(0, 1, -5);
addPlatform(3, 2, -8);
addPlatform(-3, 3, -12);
addPlatform(0, 4, -15);
addPlatform(5, 1, 5);
addPlatform(-5, 1.5, 5);
addPlatform(8, 2, 0);
addPlatform(-8, 2, 0);

// Physics constants
const gravity = -0.04;
const moveSpeed = 0.15;
const jumpForce = 0.9;

// Input handling
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

// Camera rotation (mouse drag)
let isDragging = false, prevMouse = {x:0, y:0};
let yaw = 0, pitch = 0;

document.addEventListener('mousedown', e => {
  isDragging = true;
  prevMouse.x = e.clientX;
  prevMouse.y = e.clientY;
});
document.addEventListener('mouseup', () => isDragging = false);
document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  prevMouse.x = e.clientX;
  prevMouse.y = e.clientY;
  yaw -= dx * 0.003;
  pitch -= dy * 0.003;
  pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
});

// Collision with platforms
function checkCollisions() {
  canJump = false;
  const playerBox = new THREE.Box3().setFromObject(player);

  for (let obj of objects) {
    const box = new THREE.Box3().setFromObject(obj);
    if (playerBox.intersectsBox(box)) {
      // simple Y collision handling
      if (player.position.y > obj.position.y) {
        player.position.y = obj.position.y + 0.75;
        velocity.y = 0;
        canJump = true;
      }
    }
  }

  // ground collision
  if (player.position.y <= 0.5) {
    player.position.y = 0.5;
    velocity.y = 0;
    canJump = true;
  }
}

// Game loop
function animate() {
  requestAnimationFrame(animate);

  // Apply gravity
  velocity.y += gravity;

  // Move player
  let dir = new THREE.Vector3();
  if (keys['KeyW']) dir.z -= 1;
  if (keys['KeyS']) dir.z += 1;
  if (keys['KeyA']) dir.x -= 1;
  if (keys['KeyD']) dir.x += 1;
  dir.normalize();

  // apply direction based on camera rotation
  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
  const move = new THREE.Vector3();
  move.addScaledVector(forward, dir.z);
  move.addScaledVector(right, dir.x);
  move.normalize().multiplyScalar(moveSpeed);

  player.position.add(move);
  player.position.y += velocity.y;

  // Jump
  if (keys['Space'] && canJump) {
    velocity.y = jumpForce;
    canJump = false;
  }

  // Collisions
  checkCollisions();

  // Update camera position behind player
  const camDist = 6;
  const camHeight = 3;
  const camX = player.position.x + Math.sin(yaw) * camDist;
  const camZ = player.position.z + Math.cos(yaw) * camDist;
  const camY = player.position.y + camHeight;
  camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.15);
  camera.lookAt(player.position.x, player.position.y + 0.5 + pitch * 2, player.position.z);

  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
